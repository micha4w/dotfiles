"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const path_1 = __importDefault(require("path"));
const ts_morph_1 = require("ts-morph");
ts_morph_1.Node.isObjectProperty = (node) => (ts_morph_1.Node.isPropertyDeclaration(node)
    || ts_morph_1.Node.isPropertyAssignment(node)
    || ts_morph_1.Node.isPropertySignature(node));
/** Get children for object node */
function getChildProperties(node) {
    var _a, _b;
    const properties = (_a = node === null || node === void 0 ? void 0 : node.getType()) === null || _a === void 0 ? void 0 : _a.getProperties();
    const valueDeclarations = (_b = properties.map((child) => child.getValueDeclaration())) === null || _b === void 0 ? void 0 : _b.filter((child) => node.getFullText().includes(child === null || child === void 0 ? void 0 : child.getFullText()));
    return (valueDeclarations !== null && valueDeclarations !== void 0 ? valueDeclarations : []);
}
function getJsDoc(node) {
    return node.getJsDocs().at(-1);
}
/** Get JSDoc for a node or create one if there isn't any */
function getJsDocOrCreate(node) {
    return getJsDoc(node) || node.addJsDoc({});
}
/**
 * getJsDocOrCreate, but if JSDoc is created, insert a newline at the beginning
 * so that the first line of JSDoc doesn't appear on the same line as `/**`
 */
function getJsDocOrCreateMultiline(node) {
    return getJsDoc(node) || node.addJsDoc({
        description: "\n",
    });
}
/** Return the node most suitable for JSDoc for a function, adding JSDoc if there isn't any */
function getOutputJsDocNodeOrCreate(functionNode, docNode) {
    if (docNode) {
        const funcNodeDocs = functionNode.getJsDocs();
        if (funcNodeDocs.length)
            return functionNode;
        getJsDocOrCreateMultiline(docNode);
        return docNode;
    }
    getJsDocOrCreateMultiline(functionNode);
    return functionNode;
}
/** Generate `@typedef` declarations for type imports */
function generateImportDeclarationDocumentation(importDeclaration) {
    var _a, _b;
    let typedefs = "";
    const moduleSpecifier = importDeclaration.getModuleSpecifierValue();
    const declarationIsTypeOnly = importDeclaration.isTypeOnly();
    const defaultImport = (_a = importDeclaration.getDefaultImport()) === null || _a === void 0 ? void 0 : _a.getText();
    if (defaultImport && declarationIsTypeOnly) {
        typedefs += `/** @typedef {import('${moduleSpecifier}')} ${defaultImport} */\n`;
    }
    for (const namedImport of (_b = importDeclaration.getNamedImports()) !== null && _b !== void 0 ? _b : []) {
        if (!declarationIsTypeOnly && !namedImport.isTypeOnly())
            continue;
        const name = namedImport.getName();
        const aliasNode = namedImport.getAliasNode();
        const alias = (aliasNode === null || aliasNode === void 0 ? void 0 : aliasNode.getText()) || name;
        typedefs += `/** @typedef {import('${moduleSpecifier}').${name}} ${alias} */\n`;
    }
    return typedefs;
}
/**
 * Generate `@param` documentation from function parameters for functionNode, storing it in docNode
 */
function generateParameterDocumentation(functionNode, docNode) {
    var _a, _b, _c;
    const params = functionNode.getParameters();
    if (!params.length)
        return;
    const jsDoc = getJsDocOrCreateMultiline(docNode);
    // Get existing param tags, store their comments, then remove them
    const paramTags = (jsDoc.getTags() || [])
        .filter((tag) => ["param", "parameter"].includes(tag.getTagName()));
    const commentLookup = Object.fromEntries(paramTags.map((tag) => {
        var _a;
        return [
            // @ts-ignore
            (_a = tag.compilerNode.name) === null || _a === void 0 ? void 0 : _a.getText().replace(/\[|\]|(=.*)/g, "").trim(),
            (tag.getComment() || "").toString().trim(),
        ];
    }));
    const preferredTagName = (_a = paramTags[0]) === null || _a === void 0 ? void 0 : _a.getTagName();
    paramTags.forEach((tag) => tag.remove());
    for (const param of params) {
        const paramType = ((_b = param.getTypeNode()) === null || _b === void 0 ? void 0 : _b.getText()) || param.getType().getText();
        if (!paramType)
            continue;
        const paramName = (_c = param.compilerNode.name) === null || _c === void 0 ? void 0 : _c.getText();
        const isOptional = param.isOptional();
        const isRest = param.isRestParameter();
        // Rest parameters are arrays, but the JSDoc syntax is `...number` instead of `number[]`
        const paramTypeOut = isRest ? `...${paramType.replace(/\[\]\s*$/, "")}` : paramType;
        let defaultValue;
        if (isOptional) {
            const paramInitializer = param.getInitializer();
            defaultValue = paramInitializer === null || paramInitializer === void 0 ? void 0 : paramInitializer.getText().replaceAll(/(\s|\t)*\n(\s|\t)*/g, " ");
        }
        let paramNameOut = paramName;
        // Skip parameter names if they are present in the type as an object literal
        // e.g. destructuring; { a }: { a: string }
        if (paramNameOut.match(/[{},]/))
            paramNameOut = "";
        if (paramNameOut && isOptional) {
            // Wrap name in square brackets if the parameter is optional
            const defaultValueOut = defaultValue !== undefined ? `=${defaultValue}` : "";
            paramNameOut = `[${paramNameOut}${defaultValueOut}]`;
        }
        paramNameOut = paramNameOut ? ` ${paramNameOut}` : "";
        const comment = commentLookup[paramName.trim()];
        jsDoc.addTag({
            tagName: preferredTagName || "param",
            text: `{${paramTypeOut}}${paramNameOut}${comment ? ` ${comment}` : ""}`,
        });
    }
}
/**
 * Generate `@returns` documentation from function return type for functionNode, storing it in docNode
 */
function generateReturnTypeDocumentation(functionNode, docNode) {
    var _a;
    const returnTypeNode = (_a = functionNode.getReturnTypeNode()) !== null && _a !== void 0 ? _a : functionNode.getReturnType();
    const functionReturnType = returnTypeNode.getText(functionNode.getSignature().getDeclaration());
    const jsDoc = getJsDocOrCreate(docNode);
    const returnsTag = ((jsDoc === null || jsDoc === void 0 ? void 0 : jsDoc.getTags()) || [])
        .find((tag) => ["returns", "return"].includes(tag.getTagName()));
    // Replace tag with one that contains type info if tag exists
    const tagName = (returnsTag === null || returnsTag === void 0 ? void 0 : returnsTag.getTagName()) || "returns";
    const comment = ((returnsTag === null || returnsTag === void 0 ? void 0 : returnsTag.getComment()) || "").toString().trim();
    if (returnsTag) {
        returnsTag.remove();
    }
    jsDoc.addTag({
        tagName,
        text: `{${functionReturnType}}${comment ? ` ${comment}` : ""}`,
    });
}
/**
 * Generate documentation for a function, storing it in functionNode or docNode
 */
function generateFunctionDocumentation(functionNode, docNode) {
    const outputDocNode = getOutputJsDocNodeOrCreate(functionNode, docNode);
    generateParameterDocumentation(functionNode, outputDocNode);
    generateReturnTypeDocumentation(functionNode, outputDocNode);
}
/** Generate modifier documentation for class member */
function generateModifierDocumentation(classMemberNode) {
    // const modifiers = classMemberNode.getModifiers() || [];
    // for (const modifier of modifiers) {
    //     const text = modifier === null || modifier === void 0 ? void 0 : modifier.getText();
    //     if (["public", "private", "protected", "readonly", "static"].includes(text)) {
    //         const jsDoc = getJsDocOrCreateMultiline(classMemberNode);
    //         jsDoc.addTag({ tagName: text });
    //     }
    // }
}
/**
 * Create class property initializer in constructor if it doesn't exist
 * so that documentation is preserved when transpiling
 */
function generateInitializerDocumentation(classPropertyNode) {
    var _a, _b;
    if (!((_a = classPropertyNode.getStructure()) === null || _a === void 0 ? void 0 : _a.initializer)) {
        classPropertyNode.setInitializer("undefined");
    }
    const initializer = (_b = classPropertyNode.getStructure()) === null || _b === void 0 ? void 0 : _b.initializer;
    if (initializer !== "undefined") {
        const jsDoc = getJsDocOrCreate(classPropertyNode);
        jsDoc.addTag({ tagName: "default", text: initializer });
    }
}
/** Document the class itself; at the moment just its extends signature */
function generateClassBaseDocumentation(classNode) {
    const extendedClass = classNode.getExtends();
    if (extendedClass) {
        const jsDoc = getJsDocOrCreate(classNode);
        jsDoc.addTag({ tagName: "extends", text: extendedClass.getText() });
    }
}
/** Generate documentation for class members in general; either property or method */
function generateClassMemberDocumentation(classMemberNode) {
    generateModifierDocumentation(classMemberNode);
    ts_morph_1.Node.isObjectProperty(classMemberNode) && generateInitializerDocumentation(classMemberNode);
    ts_morph_1.Node.isMethodDeclaration(classMemberNode) && generateFunctionDocumentation(classMemberNode);
}
/** Generate documentation for a class â€” itself and its members */
function generateClassDocumentation(classNode) {
    generateClassBaseDocumentation(classNode);
    classNode.getMembers().forEach(generateClassMemberDocumentation);
}
/**
 * Generate `@typedefs` from type aliases
 * @return A JSDoc comment containing the typedef
 */
function generateTypedefDocumentation(typeAlias) {
    const name = typeAlias.getName();
    const typeNode = typeAlias.getTypeNode();
    const isObjectType = ts_morph_1.Node.isTypeLiteral(typeNode) && typeAlias.getType().isObject();
    const properties = isObjectType ? typeNode.getProperties() : [];
    const typeParams = typeAlias.getTypeParameters();
    // If we're going to have multiple tags, we need to create a multiline JSDoc
    const jsDoc = properties.length || typeParams.length
        ? getJsDocOrCreateMultiline(typeAlias)
        : getJsDocOrCreate(typeAlias);
    if (ts_morph_1.Node.isTypeLiteral(typeNode) && typeAlias.getType().isObject()) {
        jsDoc.addTag({ tagName: "typedef", text: `{Object} ${name}` });
        typeNode.getProperties().forEach((prop) => {
            generateObjectPropertyDocumentation(prop, jsDoc);
        });
    }
    else {
        const { type } = typeAlias.getStructure();
        if (typeof type !== "string")
            return jsDoc.getFullText();
        jsDoc.addTag({ tagName: "typedef", text: `{${type}} ${name}` });
    }
    typeParams.forEach((param) => {
        const constraint = param.getConstraint();
        const defaultType = param.getDefault();
        const paramName = param.getName();
        const nameWithDefault = defaultType ? `[${paramName}=${defaultType.getText()}]` : paramName;
        jsDoc.addTag({
            tagName: "template",
            text: `${constraint ? `{${constraint.getText()}} ` : ""}${nameWithDefault}`,
        });
    });
    return jsDoc.getFullText();
}
/**
 * Generate documentation for object properties; runs recursively for nested objects
 * @param node
 * @param jsDoc
 * @param [name=""] The name to assign child docs to;
 *		"obj" will generate docs for "obj.val1", "obj.val2", etc
 * @param [topLevelCall=true] recursive functions are funky
 */
function generateObjectPropertyDocumentation(node, jsDoc, name = "", topLevelCall = true) {
    var _a, _b, _c, _d, _e, _f, _g, _h, _j;
    name = name || node.getName();
    if (!topLevelCall)
        name = `${name}.${node.getName()}`;
    let propType = (_c = (_b = (_a = node.getTypeNode()) === null || _a === void 0 ? void 0 : _a.getText()) === null || _b === void 0 ? void 0 : _b.replace(/\n/g, "")) === null || _c === void 0 ? void 0 : _c.trim();
    const isOptional = node.hasQuestionToken()
        || ((_f = (_e = (_d = node.getJsDocs()) === null || _d === void 0 ? void 0 : _d[0]) === null || _e === void 0 ? void 0 : _e.getTags()) === null || _f === void 0 ? void 0 : _f.some((tag) => tag.getTagName() === "optional"));
    // Copy over existing description if there is one
    const existingPropDocs = ((_j = (_h = (_g = node.getJsDocs()) === null || _g === void 0 ? void 0 : _g[0]) === null || _h === void 0 ? void 0 : _h.getDescription()) === null || _j === void 0 ? void 0 : _j.trim()) || "";
    const children = getChildProperties(node);
    if (children.length)
        propType = "Object";
    jsDoc.addTag({
        tagName: "property",
        text: `{${propType}} ${isOptional ? `[${name}]` : name} ${existingPropDocs}`,
    });
    if (children.length) {
        children.forEach((child) => generateObjectPropertyDocumentation(child, jsDoc, name, false));
    }
}
/** Generate `@typedefs` from interfaces */
function generateInterfaceDocumentation(interfaceNode) {
    const name = interfaceNode.getName();
    const jsDoc = getJsDocOrCreateMultiline(interfaceNode);
    jsDoc.addTag({ tagName: "typedef", text: `{Object} ${name}` });
    interfaceNode.getProperties().forEach((prop) => {
        generateObjectPropertyDocumentation(prop, jsDoc);
    });
    return jsDoc.getFullText();
}
/** Generate documentation for top-level var, const, and let declarations */
function generateTopLevelVariableDocumentation(varNode) {
    var _a, _b;
    const paramType = (_a = (varNode.getTypeNode() || varNode.getType())) === null || _a === void 0 ? void 0 : _a.getText();
    if (!paramType) {
        return;
    }
    const jsDoc = getJsDoc(varNode.getVariableStatement());
    if (!jsDoc) {
        // Only generate documentation for variables that have an existing comment in JSDoc format
        return;
    }
    const tags = (jsDoc === null || jsDoc === void 0 ? void 0 : jsDoc.getTags()) || [];
    if (tags.find((tag) => ["type"].includes(tag.getTagName()))) {
        return;
    }
    const constTag = tags.find((tag) => ["const", "constant"].includes(tag.getTagName()));
    if (constTag && ((_b = constTag.getComment()) === null || _b === void 0 ? void 0 : _b.length)) {
        return;
    }
    jsDoc.addTag({
        tagName: "type",
        text: `{${paramType}}`,
    });
}
/**
 * Transpile.
 * @param src Source code to transpile
 * @param [filename=input.ts] Filename to use internally when transpiling (can be a path or a name)
 * @param [compilerOptions={}] Options for the compiler.
 * 		See https://www.typescriptlang.org/tsconfig#compilerOptions
 * @param [debug=false] Whether to log errors
 * @return Transpiled code (or the original source code if something went wrong)
 */
function transpile(src, filename = "input.ts", compilerOptions = {}, debug = false) {
    var _a, _b, _c;
    // Useless variable to prevent comments from getting removed when code contains just
    // typedefs/interfaces, which get transpiled to nothing but comments
    const protectCommentsHeader = "const __tsToJsdoc_protectCommentsHeader = 1;\n";
    src = protectCommentsHeader + src;
    try {
        const project = new ts_morph_1.Project({
            compilerOptions: Object.assign({ target: ts_morph_1.ScriptTarget.ESNext, esModuleInterop: true }, compilerOptions),
        });
        // Preserve blank lines in output
        const blankLineMarker = "// TS-TO-JSDOC BLANK LINE //";
        const code = src.split("\n").map((line) => (line.match(/^[\s\t]*$/) ? (blankLineMarker + line) : line)).join("\n");
        // ts-morph throws a fit if the path already exists
        const sourceFile = project.createSourceFile(`${path_1.default.basename(filename, ".ts")}.ts-to-jsdoc.ts`, code);
        sourceFile.getClasses().forEach(generateClassDocumentation);
        const importDeclarations = sourceFile.getImportDeclarations()
            .map((declaration) => generateImportDeclarationDocumentation(declaration).trim())
            .join("\n")
            .trim();
        const typedefs = sourceFile.getTypeAliases()
            .map((typeAlias) => generateTypedefDocumentation(typeAlias).trim())
            .join("\n")
            .trim();
        const interfaces = sourceFile.getInterfaces()
            .map((interfaceNode) => generateInterfaceDocumentation(interfaceNode).trim())
            .join("\n")
            .trim();
        const directFunctions = sourceFile.getFunctions();
        directFunctions.forEach((node) => generateFunctionDocumentation(node));
        const varDeclarations = sourceFile.getVariableDeclarations();
        varDeclarations.forEach((varDeclaration) => {
            const initializer = varDeclaration.getInitializerIfKind(ts_morph_1.SyntaxKind.ArrowFunction)
                || varDeclaration.getInitializerIfKind(ts_morph_1.SyntaxKind.FunctionExpression);
            if (initializer) {
                generateFunctionDocumentation(initializer, varDeclaration.getVariableStatement());
            }
            else {
                generateTopLevelVariableDocumentation(varDeclaration);
            }
        });
        let result = (_c = (_b = (_a = project
            .emitToMemory()) === null || _a === void 0 ? void 0 : _a.getFiles()) === null || _b === void 0 ? void 0 : _b.find((file) => file.filePath.slice(0, -3) === sourceFile.getFilePath().slice(0, -3))) === null || _c === void 0 ? void 0 : _c.text;
        if (result) {
            if (!result.startsWith(protectCommentsHeader)) {
                throw new Error("Internal error: generated header is missing in output.\n\n"
                    + `Output: ${JSON.stringify(`${result.slice(protectCommentsHeader.length + 100)} ...`)}`);
            }
            result = result.replace(protectCommentsHeader, "");
            // Restore blank lines in output
            result = result.split("\n").map((_line) => {
                const line = _line.trim();
                return line.startsWith(blankLineMarker)
                    ? line.slice(blankLineMarker.length)
                    : _line;
            }).join("\n").trim();
            if (importDeclarations)
                result = `${importDeclarations}\n\n${result}`;
            if (typedefs)
                result += `\n\n${typedefs}`;
            if (interfaces)
                result += `\n\n${interfaces}`;
            result = `${result.trim()}\n`;
            return result;
        }
        throw new Error("Could not emit output to memory.");
    }
    catch (e) {
        debug && console.error(e);
        return src;
    }
    return src;
}
module.exports = transpile;
exports.default = transpile;
